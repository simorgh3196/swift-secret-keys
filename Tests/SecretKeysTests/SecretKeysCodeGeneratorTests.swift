// The MIT License (MIT)
//
// Copyright (c) 2022 Tomoya Hayakawa (github.com/simorgh3196).

@testable import secret_keys
import XCTest
import Yams

final class SecretKeysCodeGeneratorTests: XCTestCase {
    private let secretValueEncoder = SecretValueEncoder()

    func testGenerateMinimumCode() {
        let code = SecretKeysCodeGenerator.generateCode(
            namespace: "NAMESPACE",
            secrets: [],
            salt: [0x0, 0xab, 0x01, 0x16],
            encoder: secretValueEncoder,
            includeBase: false
        )

        XCTAssertEqual(code, """
            // DO NOT MODIFY
            // Automatically generated by SecretKeys (https://github.com/simorgh3196/swift-secret-keys)

            import Foundation

            extension NAMESPACE {
                private static let salt: [UInt8] = [
                    0x0, 0xab, 0x1, 0x16
                ]

            }

            """
        )
    }

    func testGenerateCodeIncludeBase() {
        let code = SecretKeysCodeGenerator.generateCode(
            namespace: "NAMESPACE",
            secrets: [],
            salt: [0x0, 0xab, 0x01, 0x16],
            encoder: secretValueEncoder,
            includeBase: true
        )

        XCTAssertEqual(code, """
            // DO NOT MODIFY
            // Automatically generated by SecretKeys (https://github.com/simorgh3196/swift-secret-keys)

            import Foundation

            public enum NAMESPACE {
                static let decoder = SecretValueDecoder()
            }

            extension NAMESPACE {
                private static let salt: [UInt8] = [
                    0x0, 0xab, 0x1, 0x16
                ]

            }

            """
        )
    }

    func testGenerateCodeWithSecret() {
        let boolSecret = Secret(name: "bool", value: .bool(true), configuredSecrets: [:])
        let doubleSecret = Secret(name: "double", value: .double(1.23), configuredSecrets: [:])
        let intSecret = Secret(name: "number", value: .int(1), configuredSecrets: [:])
        let stringSecret = Secret(name: "string", value: .string("one"), configuredSecrets: [:])
        let salt: [UInt8] = [0x0, 0xab, 0x01, 0x16]
        let boolEncodedBytes = secretValueEncoder.encode(value: boolSecret.value, with: salt)
        let doubleEncodedBytes = secretValueEncoder.encode(value: doubleSecret.value, with: salt)
        let intEncodedBytes = secretValueEncoder.encode(value: intSecret.value, with: salt)
        let stringEncodedBytes = secretValueEncoder.encode(value: stringSecret.value, with: salt)

        let code = SecretKeysCodeGenerator.generateCode(
            namespace: "NAMESPACE",
            secrets: [boolSecret, doubleSecret, intSecret, stringSecret],
            salt: salt,
            encoder: secretValueEncoder,
            includeBase: false
        )

        XCTAssertEqual(code, """
            // DO NOT MODIFY
            // Automatically generated by SecretKeys (https://github.com/simorgh3196/swift-secret-keys)

            import Foundation

            extension NAMESPACE {
                private static let salt: [UInt8] = [
                    0x0, 0xab, 0x1, 0x16
                ]

                @inline(__always)
                public static let bool: Bool = {
                    let encodedBytes: [UInt8] = [
                        \(convertBytesTo16RadixString(from: boolEncodedBytes))
                    ]

                    return try! Self.decoder.decode(bytes: encodedBytes, with: Self.salt)
                }()

                @inline(__always)
                public static let double: Double = {
                    let encodedBytes: [UInt8] = [
                        \(convertBytesTo16RadixString(from: doubleEncodedBytes))
                    ]

                    return try! Self.decoder.decode(bytes: encodedBytes, with: Self.salt)
                }()

                @inline(__always)
                public static let number: Int = {
                    let encodedBytes: [UInt8] = [
                        \(convertBytesTo16RadixString(from: intEncodedBytes))
                    ]

                    return try! Self.decoder.decode(bytes: encodedBytes, with: Self.salt)
                }()

                @inline(__always)
                public static let string: String = {
                    let encodedBytes: [UInt8] = [
                        \(convertBytesTo16RadixString(from: stringEncodedBytes))
                    ]

                    return try! Self.decoder.decode(bytes: encodedBytes, with: Self.salt)
                }()
            }

            """
        )
    }

    func testGenerateCodeWithConfiguredSecret() {
        let stringSecret = Secret(name: "string", value: .string("default"), configuredSecrets: [
            "DEBUG": .string("debug"),
            "TEST": .string("test")
        ])
        let salt: [UInt8] = [0x0, 0xab, 0x01, 0x16]
        let defaultEncodedBytes = secretValueEncoder.encode(value: stringSecret.value, with: salt)
        let debugEncodedBytes = secretValueEncoder.encode(value: stringSecret.configuredSecrets["DEBUG"]!, with: salt)
        let testEncodedBytes = secretValueEncoder.encode(value: stringSecret.configuredSecrets["TEST"]!, with: salt)

        let code = SecretKeysCodeGenerator.generateCode(
            namespace: "NAMESPACE",
            secrets: [stringSecret],
            salt: salt,
            encoder: secretValueEncoder,
            includeBase: false
        )

        XCTAssertEqual(code, """
            // DO NOT MODIFY
            // Automatically generated by SecretKeys (https://github.com/simorgh3196/swift-secret-keys)

            import Foundation

            extension NAMESPACE {
                private static let salt: [UInt8] = [
                    0x0, 0xab, 0x1, 0x16
                ]

                @inline(__always)
                public static let string: String = {
            #if DEBUG
                    let encodedBytes: [UInt8] = [
                        \(convertBytesTo16RadixString(from: debugEncodedBytes))
                    ]
            #elseif TEST
                    let encodedBytes: [UInt8] = [
                        \(convertBytesTo16RadixString(from: testEncodedBytes))
                    ]
            #else
                    let encodedBytes: [UInt8] = [
                        \(convertBytesTo16RadixString(from: defaultEncodedBytes))
                    ]
            #endif

                    return try! Self.decoder.decode(bytes: encodedBytes, with: Self.salt)
                }()
            }

            """
        )
    }

    private func convertBytesTo16RadixString(from bytes: [UInt8]) -> String {
        bytes.map { "0x" + String($0, radix: 16) }.joined(separator: ", ")
    }
}
